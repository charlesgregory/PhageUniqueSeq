//import com.nfsdb.journal.exceptions.JournalException;
import com.questdb.ex.JournalException;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.biojava.nbio.core.exceptions.CompoundNotFoundException;
import org.biojava.nbio.core.sequence.DNASequence;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;


/**
 Copyright (C) 2016  Thomas Gregory

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Created by Thomas on 3/1/2016.
 * Manages HSQL Database
 */
@SuppressWarnings("Duplicates")
public class HSqlManager {
    static final String JDBC_DRIVER_HSQL = "org.hsqldb.jdbc.JDBCDriver";
    static final String JDBC_DRIVER_H2 = "org.h2.Driver";
    static final String DB_SERVER_URL ="jdbc:hsqldb:hsql://localhost/primerdb";
    static final String DB_SERVER_URL_H2 ="jdbc:h2:primerdb;LOG=0;LOCK_MODE=0;CACHE_SIZE=65536;" +
            "UNDO_LOG=0;WRITE_DELAY=20";
    static final String DB_SERVER_URL_Header ="jdbc:hsqldb:hsql://localhost/";
    static final String DB_SERVER_URL_Exists="primerdb;ifexists=true";
    static final String DB_SERVER_URL_Mod=";file:database/";
    static final String DB_URL_HSQL_C = "jdbc:hsqldb:file:database/primerdb";
    private static ImportPhagelist INSTANCE;
    private static HSqlManager instance;
    public final Connection conn;
    public static List<String[]> newPhages;
    private static final String USER = "SA";
    private static final String PASS = "";
    private static boolean written = false;

    //Initial Connection Constructor for Database initial build
    private HSqlManager() throws IOException,
            ClassNotFoundException, SQLException, IllegalAccessException, InstantiationException {
        INSTANCE = ImportPhagelist.getInstance();
        Class.forName(JDBC_DRIVER_H2).newInstance();
        conn = DriverManager.getConnection(DB_SERVER_URL,USER,PASS);
        System.out.println("PrimerDB connected");
    }
    public HSqlManager(String url) throws IOException,
            ClassNotFoundException, SQLException, IllegalAccessException, InstantiationException {
        INSTANCE = ImportPhagelist.getInstance();
        Class.forName(JDBC_DRIVER_H2).newInstance();
        conn = DriverManager.getConnection(url,USER,PASS);
        System.out.println("PrimerDB connected");
    }
    //Returns the Instance of the manager
    public static HSqlManager getInstance() throws IOException,
            SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (instance == null) {
            instance = new HSqlManager();
        }
        return instance;
    }
    //Main for Initial DB Build
    public static void main(String[] args) throws ClassNotFoundException,
            SQLException, InstantiationException, IllegalAccessException, IOException, CompoundNotFoundException, JournalException {
        HSqlManager db = new HSqlManager(DB_SERVER_URL_H2);
        db.dbBuild();
        if(args.length>1&&args[1].equals("-full")){
            Main.main(new String[]{"-update","-new","18","25"});
            Main.main(new String[]{"-update","-pick"});
        }
    }
    //runs Initial build and common clustering
    public void dbBuild() throws SQLException, ClassNotFoundException, IOException,
            InstantiationException, IllegalAccessException {
        dbInit();
        primerDBsetup();
    }

    //Sets up DB and tables
    private void dbInit() throws SQLException {
        Statement init = conn.createStatement();
        init.executeUpdate("CREATE SCHEMA Primerdb AUTHORIZATION SA");
        init.executeUpdate(" CREATE CACHED TABLE Primers( " +
                " id INTEGER GENERATED BY DEFAULT AS IDENTITY, " +
                " Sequence BIGINT NOT NULL, " +
                " Strain VARCHAR(45) NOT NULL, " +
                " Cluster VARCHAR(45) NOT NULL, " +
                " UniqueP BOOLEAN NULL, " +
                " Hairpin BOOLEAN NULL, "+
                " PRIMARY KEY (id)) ");
        init.executeUpdate(" CREATE CACHED TABLE MatchedPrimers( " +
                " id INTEGER GENERATED BY DEFAULT AS IDENTITY, " +
                " Primer BIGINT NOT NULL, " +
                " PrimerMatch BIGINT NOT NULL, " +
                " Comp FLOAT NULL, " +
                " FragAVG FLOAT NULL, " +
                " FragVAR FLOAT NULL, " +
                " H2SD FLOAT NULL, " +
                " L2SD FLOAT NULL, " +
                " Strain VARCHAR(45) NOT NULL, " +
                " Cluster VARCHAR(45) NOT NULL, " +
                " PRIMARY KEY (id)) ");
        init.executeUpdate(" CREATE CACHED TABLE Phages( " +
                " id INTEGER GENERATED BY DEFAULT AS IDENTITY, " +
                " Name VARCHAR(45) NOT NULL, " +
                " Cluster VARCHAR(45) NOT NULL, " +
                " Strain VARCHAR(45) NOT NULL, " +
                " PRIMARY KEY (id)) ");
        init.executeUpdate("SET WRITE_DELAY 20");
        init.executeUpdate("SET REFERENTIAL_INTEGRITY FALSE");
//        init.executeUpdate("SET UNDO_LOG 0");

        init.executeUpdate("CREATE INDEX a on primers(Cluster)");
        init.executeUpdate("CREATE INDEX b on primers(Strain)");
        init.executeUpdate("CREATE INDEX d on matchedprimers(Cluster)");
        init.executeUpdate("CREATE INDEX e on matchedprimers(Strain)");
        init.executeUpdate("CREATE INDEX r on phages(Cluster)");
        init.executeUpdate("CREATE INDEX s on phages(Strain)");
        System.out.println("Database Initialized");
    }
    //Inserts current strains, clusters and phages
    private void primerDBsetup() throws SQLException, IOException {
        System.out.println("Building DB");
        PreparedStatement insertPhage = conn
                .prepareStatement("INSERT INTO Phages" +
                        "(Name, Cluster, Strain) values(?,?,?);");
        FastaManager.download();
        Map<List<String>, DNASequence> fastaMap = FastaManager.getMultiFasta();
        for (List<String> x:fastaMap.keySet()){
            insertPhage.setString(1,x.get(2));
            insertPhage.setString(2,x.get(1));
            insertPhage.setString(3,x.get(0));
            insertPhage.addBatch();
        }
        insertPhage.executeBatch();
        insertPhage.close();
        System.out.println("DB Built");
    }

    public static void primerAnalysis(Connection connection, int bps) throws SQLException, IOException {
        long time = System.currentTimeMillis();
        System.out.println((System.currentTimeMillis()-time ) / Math.pow(10, 3)/60);
        time = System.currentTimeMillis();
        written = true;
        Map<List<String>, DNASequence> fastas = FastaManager.getMultiFasta();
        Connection db = connection;
        Statement stat = db.createStatement();
        stat.execute("SET AUTOCOMMIT FALSE;");
        stat.execute("SET LOG 0;");
        PreparedStatement st = db.prepareStatement("INSERT INTO Primers" +
                "(Sequence,Strain,Cluster,UniqueP,Hairpin) " +
                "VALUES(?,?,?,true,?)");
        ResultSet call = stat.executeQuery("Select * From Phages;");
        List<String[]> phages = new ArrayList<>();
        while (call.next()) {
            String[] r = new String[3];
            r[0]=call.getString("Strain");
            r[1]=call.getString("Cluster");
            r[2]=call.getString("Name");
            phages.add(r);

        }
        call.close();

        Set<String>strains = phages.stream().map(y->y[0]).collect(Collectors.toSet());
        for(String x:strains) {
            Set<String> clust = phages.stream().filter(y -> y[0].equals(x)).map(y -> y[1]).collect(Collectors.toSet());
            Map<String, Integer> clustersNum = new HashMap<>();
            Map<Integer, String> clustersName = new HashMap<>();
            Map<Integer, List<String>> clusters = new HashMap<>();
            Map<Long, Primer> primers = new HashMap<>();
            int i = 0;
            for (String cluster : clust) {
                clustersName.put(i, cluster);
                clustersNum.put(cluster, i);
                i++;
            }
            clust.parallelStream().forEach(cluster -> clusters.put(clustersNum.get(cluster),
                    phages.stream()
                            .filter(a -> a[0].equals(x) && a[1].equals(cluster))
                            .map(a -> a[2])
                            .collect(Collectors.toList())));
            for (int z : clusters.keySet()) {

                List<String> clustphages = clusters.get(z);
                for (String phage : clustphages) {

                    Set<Long> phagprimers= new HashSet<>();
                    List<String> id = new ArrayList<>();
                    id.add(x);
                    id.add(clustersName.get(z));
                    id.add(phage);
                    String sequence = fastas.get(id).getSequenceAsString()+
                            fastas.get(id).getReverseComplement().getSequenceAsString();
                    for (int k = 0; k <= sequence.length() - bps; k++) {
                         phagprimers.add(Encoding.twoBitEncoding(sequence.substring(k, k + bps)));
                    }
                    for (long primer : phagprimers) {
                        if (!primers.containsKey(primer)) {
                            primers.put(primer, new Primer(z));
                        } else {
                            Primer select = primers.get(primer);
                            select.phageCount++;
                            if (!select.containsCluster(z)) {
                                select.addCluster(z);
                            }
                        }

                    }

                }
                System.out.print("\r");
                System.out.print(clustersName.get(z));
            }
            int count = 0;

            Iterator<Map.Entry<Long, Primer>> primersSet = primers.entrySet().iterator();
            while (primersSet.hasNext()) {

                Map.Entry<Long, Primer> primer = primersSet.next();
                Primer primerInf = primer.getValue();
                if (primerInf.clusters.length != 1) {
                    primer.setValue(null);
                } else {
                    int primerClust = -1;
                    for (int cluster : primerInf.clusters) {
                        primerClust = cluster;
                    }
                    if (primerInf.phageCount != clusters.get(primerClust).size()) {
                        primer.setValue(null);
                    } else {
                        count++;
                    }
                }
            }
            System.out.print("\r");
            System.out.print("Strain "+x+" done!");
            System.out.print("Unique Count: ");
            System.out.println(count);
            System.out.print("Primer Count: ");
            System.out.println(primers.size());
            i = 0;

            for (Long a : primers.keySet()) {
                Primer primerInf = primers.get(a);
                if (primerInf != null) {
                    String primerClust = "";
                    for (int cluster : primerInf.clusters) {
                        primerClust = clustersName.get(cluster);
                    }

                    try {

                        st.setLong(1, a);
                        st.setString(2, x);
                        st.setString(3, primerClust);
                        st.setBoolean(4, HSqlPrimerDesign.calcHairpin(Encoding.twoBitDecode(a), 4));
                        st.addBatch();
                    } catch (SQLException e) {
                        e.printStackTrace();
                        System.out.println("Error occurred at " + x + " " + primerClust);
                    }
                    i++;
                    if (i == 1000) {
                        i = 0;
                        st.executeBatch();
                        db.commit();
                    }
                }
            }
            if (i > 0) {
                st.executeBatch();
                db.commit();
            }



            System.out.println(bps+" Unique Updated");
            System.out.println((System.currentTimeMillis() - time) / Math.pow(10, 3) / 60);
        }
        stat.execute("SET AUTOCOMMIT TRUE ;");
        stat.execute("SET LOG 1;");
        st.close();
        stat.close();
    }


    public static void clearDatabase(Connection connection) throws SQLException {
        Connection db = connection;
        Statement stmt = db.createStatement();
        stmt.execute("TRUNCATE SCHEMA Primerdb RESTART IDENTITY AND COMMIT NO CHECK");
    }
    //Key object for unique sequence map
    private static class Bytes{
        byte[] bytes;
        Bytes(byte[] b){
            bytes=b;
        }
        @Override
        public int hashCode() {
            return new HashCodeBuilder(17, 31). // two randomly chosen prime numbers
                    // if deriving: appendSuper(super.hashCode()).
                            append(bytes).
                            toHashCode();
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof Bytes))
                return false;
            if (obj == this)
                return true;

            Bytes rhs = (Bytes) obj;

            return Arrays.equals(bytes,rhs.bytes);
        }
    }
    //entry object that stores the data of the key in the unique sequence map
    private static class Primer{
        int[] clusters;
        int phageCount;
        Primer(int cluster){
            clusters = new int[1];
            addCluster(cluster);
            phageCount=1;
        }
        public boolean containsCluster(int cluster){
            for(int i=0;i<clusters.length;i++){
                if(clusters[i]== cluster){
                    return true;
                }
            }
            return false;
        }
        public void addCluster(int cluster){
            int[] temp = new int[phageCount+1];
            for(int i =0;i<clusters.length;i++){
                temp[i]=clusters[i];
            }
            clusters=temp;
            clusters[phageCount++]=cluster;
        }
    }
}
