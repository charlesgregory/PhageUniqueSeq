import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.biojava.nbio.core.sequence.DNASequence;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;


/**
 Copyright (C) 2016  Thomas Gregory

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Created by Thomas on 3/1/2016.
 * Manages HSQL Database
 */
@SuppressWarnings("Duplicates")
public class HSqlManager {
    static final String JDBC_DRIVER_HSQL = "org.hsqldb.jdbc.JDBCDriver";
    static final String DB_SERVER_URL ="jdbc:hsqldb:hsql://localhost/primerdbTest";
    static final String DB_SERVER_URL_Header ="jdbc:hsqldb:hsql://localhost/";
    static final String DB_SERVER_URL_Exists="primerdbTest;ifexists=true";
    static final String DB_SERVER_URL_Mod=";file:database/";
    static final String DB_URL_HSQL_C = "jdbc:hsqldb:file:database/primerdb";
    private static ImportPhagelist INSTANCE;
    private static HSqlManager instance;
    public final Connection conn;
    public static List<String[]> newPhages;
    private static final String USER = "SA";
    private static final String PASS = "";
    private static boolean written = false;

    //Initial Connection Constructor for Database initial build
    private HSqlManager() throws IOException,
            ClassNotFoundException, SQLException, IllegalAccessException, InstantiationException {
        INSTANCE = ImportPhagelist.getInstance();
        Class.forName(JDBC_DRIVER_HSQL).newInstance();
        conn = DriverManager.getConnection(DB_SERVER_URL,USER,PASS);
        System.out.println("PrimerDB connected");
    }
    public HSqlManager(String url) throws IOException,
            ClassNotFoundException, SQLException, IllegalAccessException, InstantiationException {
        INSTANCE = ImportPhagelist.getInstance();
        Class.forName(JDBC_DRIVER_HSQL).newInstance();
        conn = DriverManager.getConnection(url,USER,PASS);
        System.out.println("PrimerDB connected");
    }
    //Returns the Instance of the manager
    public static HSqlManager getInstance() throws IOException,
            SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {
        if (instance == null) {
            instance = new HSqlManager();
        }
        return instance;
    }
    //Main for Initial DB Build
    public static void main(String[] args) throws ClassNotFoundException,
            SQLException, InstantiationException, IllegalAccessException, IOException {
        HSqlManager db = new HSqlManager(DB_SERVER_URL);
        db.dbBuild();
    }
    //runs Initial build and common clustering
    public void dbBuild() throws SQLException, ClassNotFoundException, IOException,
            InstantiationException, IllegalAccessException {
        dbInit();
        primerDBsetup();
//        createAllDbs();
    }

    //Sets up DB and tables
    private void dbInit() throws SQLException {
        Statement init = conn.createStatement();
        String start2="CREATE SCHEMA Primerdb AUTHORIZATION DBA" +
                "\tCREATE CACHED TABLE Primers(\n" +
                "\tid INTEGER GENERATED BY DEFAULT AS IDENTITY,\n" +
                "\tBp INTEGER NOT NULL,\n" +
                "\tSequence BIGINT NOT NULL,\n" +
                "\tStrain VARCHAR(45) NOT NULL,\n" +
                "\tCluster VARCHAR(45) NOT NULL,\n" +
                "\tTm FLOAT NULL,\n" +
                "\tGC FLOAT NULL,\n" +
                "\tCommonP BOOLEAN NULL,\n" +
                "\tUniqueP BOOLEAN NULL,\n" +
                "\tPicked BOOLEAN NULL,\n" +
                "\tHairpin BOOLEAN NULL,\n"+
                "\tPRIMARY KEY (id))\n" +
                "\n" +
                "\tCREATE CACHED TABLE MatchedPrimers(\n" +
                "\tid INTEGER GENERATED BY DEFAULT AS IDENTITY,\n" +
                "\tBp1 INTEGER NOT NULL,\n" +
                "\tPrimer BIGINT NOT NULL,\n" +
                "\tBp2 INTEGER NOT NULL,\n" +
                "\tPrimerMatch BIGINT NOT NULL,\n" +
                "\tComp FLOAT NULL,\n" +
                "\tFragAVG FLOAT NULL,\n" +
                "\tFragVAR FLOAT NULL,\n" +
                "\tH2SD FLOAT NULL,\n" +
                "\tL2SD FLOAT NULL,\n" +
                "\tStrain VARCHAR(45) NOT NULL,\n" +
                "\tCluster VARCHAR(45) NOT NULL,\n" +
                "\tPRIMARY KEY (id))\n" +
                "\n" +
                "\tCREATE CACHED TABLE Phages(\n" +
                "\tid INTEGER GENERATED BY DEFAULT AS IDENTITY,\n" +
                "\tName VARCHAR(45) NOT NULL,\n" +
                "\tCluster VARCHAR(45) NOT NULL,\n" +
                "\tStrain VARCHAR(45) NOT NULL,\n" +
                "\tPRIMARY KEY (id))\n";
        init.executeUpdate(start2);
        init.executeUpdate("SET FILES NIO SIZE 8192 ");
        init.executeUpdate("SET FILES WRITE DELAY 20 MILLIS ");
        init.executeUpdate("SET DATABASE DEFAULT TABLE TYPE CACHED");
        init.executeUpdate("CREATE INDEX a on primerdb.primers(Cluster)");
        init.executeUpdate("CREATE INDEX b on primerdb.primers(Strain)");
//        init.executeUpdate("CREATE INDEX c on primerdb.primers(Sequence)");
        init.executeUpdate("CREATE INDEX d on primerdb.matchedprimers(Cluster)");
        init.executeUpdate("CREATE INDEX e on primerdb.matchedprimers(Strain)");
//        init.executeUpdate("CREATE INDEX f on primerdb.matchedprimers(Primer)");
//        init.executeUpdate("CREATE INDEX g on primerdb.matchedprimers(PrimerMatch)");
        init.executeUpdate("CREATE INDEX r on primerdb.phages(Cluster)");
        init.executeUpdate("CREATE INDEX s on primerdb.phages(Strain)");
        System.out.println("Database Initialized");
    }
    //Inserts current strains, clusters and phages
    private void primerDBsetup() throws SQLException, IOException {
        System.out.println("Building DB");
        PreparedStatement insertPhage = conn
                .prepareStatement("INSERT INTO Primerdb.Phages" +
                        "(Name, Cluster, Strain) values(?,?,?);");
        FastaManager.download();
        Map<List<String>, DNASequence> fastaMap = FastaManager.getMultiFasta();
        for (List<String> x:fastaMap.keySet()){
            insertPhage.setString(1,x.get(2));
            insertPhage.setString(2,x.get(1));
            insertPhage.setString(3,x.get(0));
            insertPhage.addBatch();
        }
        insertPhage.executeBatch();
        insertPhage.close();
        System.out.println("DB Built");
    }
    private void createAllDbs() throws SQLException, IOException {
        Statement statement2 = conn.createStatement();
        ResultSet call = statement2.executeQuery("Select * From Primerdb.Phages;");
        List<String[]> phages = new ArrayList<>();
        while (call.next()) {
            String[] r = new String[3];
            r[0]=call.getString("Strain");
            r[1]=call.getString("Cluster");
            r[2]=call.getString("Name");
            phages.add(r);
        }
        call.close();

        Set<String>strains = phages.stream().map(y->y[0]).collect(Collectors.toSet());
        System.out.println(strains.toString());
        for(String x:strains) {
            Set<String> clust = phages.stream().filter(y -> y[0].equals(x)).map(y -> y[1]).collect(Collectors.toSet());
            Connection dbConn = DriverManager.getConnection(DB_SERVER_URL_Header+x+DB_SERVER_URL_Mod+x,USER,PASS);
            Statement statement = dbConn.createStatement();
            String start2="CREATE SCHEMA Primerdb AUTHORIZATION DBA" +
                    "\tCREATE CACHED TABLE Primers(\n" +
                    "\tid INTEGER GENERATED BY DEFAULT AS IDENTITY,\n" +
                    "\tBp INTEGER NOT NULL,\n" +
                    "\tSequence VARCHAR(45) NOT NULL,\n" +
                    "\tStrain VARCHAR(45) NOT NULL,\n" +
                    "\tCluster VARCHAR(45) NOT NULL,\n" +
                    "\tTm FLOAT NULL,\n" +
                    "\tGC FLOAT NULL,\n" +
                    "\tCommonP BOOLEAN NULL,\n" +
                    "\tUniqueP BOOLEAN NULL,\n" +
                    "\tPicked BOOLEAN NULL,\n" +
                    "\tHairpin BOOLEAN NULL,\n"+
                    "\tPRIMARY KEY (id))\n" +
                    "\n" +
                    "\tCREATE CACHED TABLE MatchedPrimers(\n" +
                    "\tid INTEGER GENERATED BY DEFAULT AS IDENTITY,\n" +
                    "\tPrimer VARCHAR(45) NOT NULL,\n" +
                    "\tPrimerMatch VARCHAR(45) NOT NULL,\n" +
                    "\tComp FLOAT NULL,\n" +
                    "\tFragAVG FLOAT NULL,\n" +
                    "\tFragVAR FLOAT NULL,\n" +
                    "\tH2SD FLOAT NULL,\n" +
                    "\tL2SD FLOAT NULL,\n" +
                    "\tStrain VARCHAR(45) NOT NULL,\n" +
                    "\tCluster VARCHAR(45) NOT NULL,\n" +
                    "\tPRIMARY KEY (id))\n" +
                    "\n" +
                    "\tCREATE CACHED TABLE Phages(\n" +
                    "\tid INTEGER GENERATED BY DEFAULT AS IDENTITY,\n" +
                    "\tName VARCHAR(45) NOT NULL,\n" +
                    "\tCluster VARCHAR(45) NOT NULL,\n" +
                    "\tStrain VARCHAR(45) NOT NULL,\n" +
                    "\tPRIMARY KEY (id))\n";
            statement.executeUpdate(start2);
            statement.executeUpdate("SET FILES NIO SIZE 8192 ");
            statement.executeUpdate("SET DATABASE DEFAULT TABLE TYPE CACHED");
            statement.executeUpdate("CREATE INDEX a on primerdb.primers(Cluster)");
            statement.executeUpdate("CREATE INDEX b on primerdb.primers(Strain)");
            statement.executeUpdate("CREATE INDEX c on primerdb.primers(Sequence)");
            statement.executeUpdate("CREATE INDEX d on primerdb.matchedprimers(Cluster)");
            statement.executeUpdate("CREATE INDEX e on primerdb.matchedprimers(Strain)");
            statement.executeUpdate("CREATE INDEX f on primerdb.matchedprimers(Primer)");
            statement.executeUpdate("CREATE INDEX g on primerdb.matchedprimers(PrimerMatch)");
            statement.executeUpdate("CREATE INDEX r on primerdb.phages(Cluster)");
            statement.executeUpdate("CREATE INDEX s on primerdb.phages(Strain)");
            statement.close();
            PreparedStatement stat=dbConn.prepareStatement("INSERT INTO Primerdb.Phages" +
                    "(Name, Cluster, Strain) values(?,?,?);");
            for (String z : clust) {
//            try {
                List<String> clustphages = phages.stream()
                        .filter(a -> a[0].equals(x) && a[1].equals(z))
                        .map(a -> a[2])
                        .collect(Collectors.toList());
                for (String phage : clustphages) {
                    stat.setString(1,phage);
                    stat.setString(2,z);
                    stat.setString(3,x);
                    stat.addBatch();
                }
            }
            stat.executeBatch();
            stat.close();
            dbConn.close();
        }
        conn.close();
    }

    public static void primerAnalysis(Connection connection, int bps) throws SQLException, IOException {
        long time = System.currentTimeMillis();
        DpalLoad.main(new String[1]);
        HSqlPrimerDesign.Dpal_Inst = DpalLoad.INSTANCE_WIN64;
        System.out.println((System.currentTimeMillis()-time ) / Math.pow(10, 3)/60);
        time = System.currentTimeMillis();
        written = true;
        Map<List<String>, DNASequence> fastas = FastaManager.getMultiFasta();
        Connection db = connection;
        Statement stat = db.createStatement();
        stat.execute("SET AUTOCOMMIT FALSE;");
        stat.execute("SET FILES LOG FALSE;");
//        PreparedStatement st = db.prepareStatement("Insert INTO Primerdb.Primers" +
//                "(Bp,Sequence, CommonP, UniqueP, Picked, Strain, Cluster)" +
//                " Values(?,?,true,false,false,?,?)");
        PreparedStatement st = db.prepareStatement("INSERT INTO Primerdb.Primers" +
                "(Bp,Sequence,Strain,Cluster,Tm,GC,UniqueP,CommonP,Hairpin) " +
                "VALUES(?,?,?,?,?,?,true,true,?)");
        ResultSet call = stat.executeQuery("Select * From Primerdb.Phages;");
        List<String[]> phages = new ArrayList<>();
        while (call.next()) {
            String[] r = new String[3];
            r[0]=call.getString("Strain");
            r[1]=call.getString("Cluster");
            r[2]=call.getString("Name");
            phages.add(r);

//            if(strain.equals("-myco")) {
//                if (r[2].equals("xkcd")) {
//                    strain = r[0];
//                }
//            }else if(strain.equals("-arthro")){
//                if (r[2].equals("ArV1")) {
//                    strain = r[0];
//                }
//            }
        }
        call.close();

        Set<String>strains = phages.stream().map(y->y[0]).collect(Collectors.toSet());
        for(String x:strains) {
            Set<String> clust = phages.stream().filter(y -> y[0].equals(x)).map(y -> y[1]).collect(Collectors.toSet());
            Map<String, Integer> clustersNum = new HashMap<>();
            Map<Integer, String> clustersName = new HashMap<>();
            Map<Integer, List<String>> clusters = new HashMap<>();
//            Map<Bytes, Primer> primers = new HashMap<>();
            Map<Long, Primer> primers = new HashMap<>();
            int i = 0;
            for (String cluster : clust) {
                clustersName.put(i, cluster);
                clustersNum.put(cluster, i);
                i++;
            }
            clust.parallelStream().forEach(cluster -> clusters.put(clustersNum.get(cluster),
                    phages.stream()
                            .filter(a -> a[0].equals(x) && a[1].equals(cluster))
                            .map(a -> a[2])
                            .collect(Collectors.toList())));
            for (int z : clusters.keySet()) {
//            try {
                List<String> clustphages = clusters.get(z);
                for (String phage : clustphages) {
//                    Set<Bytes> phagprimers= new HashSet<>();
                    Set<Long> phagprimers= new HashSet<>();
                    List<String> id = new ArrayList<>();
                    id.add(x);
                    id.add(clustersName.get(z));
                    id.add(phage);
                    String sequence = fastas.get(id).getSequenceAsString()+
                            fastas.get(id).getReverseComplement().getSequenceAsString();
                    for (int k = 0; k <= sequence.length() - bps; k++) {
                         phagprimers.add(Encoding.twoBitEncoding(sequence.substring(k, k + bps)));
                    }
                    for (long primer : phagprimers) {
                        if (!primers.containsKey(primer)) {
                            primers.put(primer, new Primer(z));
                        } else {
                            Primer select = primers.get(primer);
                            select.phageCount++;
                            if (!select.containsCluster(z)) {
                                select.addCluster(z);
                            }
                        }

                    }

                }
                System.out.println(clustersName.get(z));
            }
            int count = 0;
//            Iterator<Map.Entry<Bytes, Primer>> primersSet = primers.entrySet().iterator();
            Iterator<Map.Entry<Long, Primer>> primersSet = primers.entrySet().iterator();
            while (primersSet.hasNext()) {
//                Map.Entry<Bytes, Primer> primer = primersSet.next();
                Map.Entry<Long, Primer> primer = primersSet.next();
                Primer primerInf = primer.getValue();
                if (primerInf.clusters.length != 1) {
                    primer.setValue(null);
                } else {
                    int primerClust = -1;
                    for (int cluster : primerInf.clusters) {
                        primerClust = cluster;
                    }
                    if (primerInf.phageCount != clusters.get(primerClust).size()) {
                        primer.setValue(null);
                    } else {
                        count++;
                    }
                }
            }
            System.out.print("Unique Count: ");
            System.out.println(count);
            System.out.print("Primer Count: ");
            System.out.println(primers.size());
            i = 0;
//            for (Bytes a : primers.keySet()) {
            for (Long a : primers.keySet()) {
                Primer primerInf = primers.get(a);
                if (primerInf != null) {
                    String primerClust = "";
                    for (int cluster : primerInf.clusters) {
                        primerClust = clustersName.get(cluster);
                    }
//                    String str = new String(a.bytes);
                    try {
                        st.setInt(1, bps);
//                        st.setLong(2, Encoding.twoBitEncoding(str));
                        st.setLong(2, a);
                        st.setString(3, x);
                        st.setString(4, primerClust);
//                        st.setDouble(5, HSqlPrimerDesign.primerTm(str, 0, 800, 1.5, 0.2));
//                        st.setDouble(5, HSqlPrimerDesign.easytm(str));
                        st.setDouble(5, HSqlPrimerDesign.easytm(Encoding.twoBitDecode(a,bps)));
//                        st.setDouble(6, HSqlPrimerDesign.gcContent(str));
                        st.setDouble(6, HSqlPrimerDesign.gcContent(Encoding.twoBitDecode(a,bps)));
//                        st.setBoolean(7, HSqlPrimerDesign.calcHairpin(str, 4));
                        st.setBoolean(7, HSqlPrimerDesign.calcHairpin(Encoding.twoBitDecode(a,bps), 4));
                        st.addBatch();
                    } catch (SQLException e) {
                        e.printStackTrace();
                        System.out.println("Error occurred at " + x + " " + primerClust);
                    }
                    i++;
                    if (i == 1000) {
                        i = 0;
                        st.executeBatch();
                        db.commit();
                    }
                }
            }
            if (i > 0) {
                st.executeBatch();
                db.commit();
            }

//        }

            System.out.println("Unique Updated");
            System.out.println((System.currentTimeMillis() - time) / Math.pow(10, 3) / 60);
        }
        stat.execute("SET AUTOCOMMIT TRUE ;");
        stat.execute("SET FILES LOG TRUE ;");
        st.close();
        stat.close();
    }
    @Deprecated
    public static void runNewMycoBP(Connection connection, int bps) throws IOException,
            SQLException, InstantiationException, IllegalAccessException, ClassNotFoundException {
//        mycoCommonInitialize(bps,connection);
//        mycoUniqueDB(connection,bps);
        primerAnalysis(connection,bps);
//        HSqlPrimerDesign.primerPicks(connection,bps);
//        connection.createStatement().execute("SHUTDOWN");
    }
    @Deprecated
    public static void runNewArthroBP(Connection connection, int bps) throws IOException,
            SQLException, InstantiationException, IllegalAccessException, ClassNotFoundException {
//        mycoCommonInitialize(bps,connection);
//        mycoUniqueDB(connection,bps);
        primerAnalysis(connection,bps);
//        HSqlPrimerDesign.primerPicks(connection,bps);
//        connection.createStatement().execute("SHUTDOWN");
    }
    public static void clearDatabase(Connection connection) throws SQLException {
        Connection db = connection;
        Statement stmt = db.createStatement();
        stmt.execute("TRUNCATE SCHEMA Primerdb RESTART IDENTITY AND COMMIT NO CHECK");
    }
    //Key object for unique sequence map
    private static class Bytes{
        byte[] bytes;
        Bytes(byte[] b){
            bytes=b;
        }
        @Override
        public int hashCode() {
            return new HashCodeBuilder(17, 31). // two randomly chosen prime numbers
                    // if deriving: appendSuper(super.hashCode()).
                            append(bytes).
                            toHashCode();
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof Bytes))
                return false;
            if (obj == this)
                return true;

            Bytes rhs = (Bytes) obj;
//            return new EqualsBuilder().
//                    // if deriving: appendSuper(super.equals(obj)).
//                            append(bytes, rhs.bytes).
//                            isEquals();
            return Arrays.equals(bytes,rhs.bytes);
        }
    }
    //entry object that stores the data of the key in the unique sequence map
    private static class Primer{
        int[] clusters;
        int phageCount;
        Primer(int cluster){
            clusters = new int[1];
            addCluster(cluster);
            phageCount=1;
        }
        public boolean containsCluster(int cluster){
            for(int i=0;i<clusters.length;i++){
                if(clusters[i]== cluster){
                    return true;
                }
            }
            return false;
        }
        public void addCluster(int cluster){
            int[] temp = new int[phageCount+1];
            for(int i =0;i<clusters.length;i++){
                temp[i]=clusters[i];
            }
            clusters=temp;
            clusters[phageCount++]=cluster;
        }
    }
}
